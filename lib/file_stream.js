module.exports = FileStream

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var stream = require('stream')

inherits(FileStream, stream.Readable)

/**
 * A readable stream of a torrent file.
 *
 * @param {Object} file
 * @param {number} opts.start stream slice of file, starting from this byte (inclusive)
 * @param {number} opts.end stream slice of file, ending with this byte (inclusive)
 * @param {number} opts.pieceLength length of an individual piece
 */
function FileStream (file, opts) {
  var self = this
  if (!(self instanceof FileStream)) return new FileStream(file, opts)
  stream.Readable.call(self, opts)

  if (!opts) opts = {}
  if (!opts.start) opts.start = 0
  if (!opts.end) opts.end = file.length - 1

  self.length = opts.end - opts.start + 1

  var offset = opts.start + file.offset
  var pieceLength = opts.pieceLength

  self.startPiece = offset / pieceLength | 0
  self.endPiece = (opts.end + file.offset) / pieceLength | 0

  self._storage = file.storage
  self._piece = self.startPiece
  self._missing = self.length
  self._reading = false
  self._notifying = false
  self._destroyed = false
  self._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
  self._offset = offset - (self.startPiece * pieceLength)
}

FileStream.prototype._read = function () {
  var self = this
  if (self._reading) return
  self._reading = true
  self.notify()
}

FileStream.prototype.notify = function () {
  var self = this

  if (!self._reading || !self._missing) return
  if (!self._storage.bitfield.get(self._piece))
    return self._storage.emit('critical', self._piece, self._piece + self._criticalLength)

  if (self._notifying) return
  self._notifying = true

  var piece = self._storage.pieces[self._piece++]
  if (!piece) {
    self._storage.emit('error', new Error('invalid piece index ' + index))
    return self.destroy(err)
  }

  piece.read(function (err, buffer) {
    self._notifying = false

    if (self._destroyed) return

    if (err) {
      self._storage.emit('error', err)
      return self.destroy(err)
    }

    if (self._offset) {
      buffer = buffer.slice(self._offset)
      self._offset = 0
    }

    if (self._missing < buffer.length) {
      buffer = buffer.slice(0, self._missing)
    }
    self._missing -= buffer.length
    self.push(buffer)

    if (!self._missing) {
      self.push(null)
    }

    self._reading = false
  })
}

FileStream.prototype.destroy = function () {
  var self = this
  if (self._destroyed) return
  self._destroyed = true
  self.emit('close')
}
